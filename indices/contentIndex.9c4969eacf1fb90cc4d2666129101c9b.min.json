{"/":{"title":"jneo8.com","content":"\n# About\n\nThis a jneo8, a software engineer who focus on cloud native/database/devops/backend topics.\n\n\n# Articles\n\n- [List of articles](/tags/articles)\n","lastmodified":"2023-01-07T06:57:36.690851697Z","tags":null},"/publish/poromodo-202301071453":{"title":"poromodo-202301071453","content":"\n# poromodo-202301071453\n\n# Summary\n\n番茄鐘工作法摘要\n\n# Notes\n\n## 如何實行\n\n\n1. 決定待完成的工作\n2. 設定番茄鐘 ( 25 mins )\n3. 持續工作一個番茄鐘 `X`\n    * 前五分鐘計畫\n    * 後五分鐘 review\n4. 休息五分鐘\n5. 每四個 `X` 休息 15 - 30 分鐘\n\n\n## 原則\n\n* 番茄鐘不可分割\n\n* 時間表優先於番茄鐘\n\n\n## 表格\n\n* 事項盤點表\n    * `U` (unplanned) 給不緊急事項, 註明截止期限\n\n* 今日工作表\n    * 上半部 今日待辦事項\n        * 紀錄待辦事項跟番茄鐘\n    * 下半部 緊急處理事項\n        * 緊急事項寫在這\n\n* 番茄鐘\n    * 內部干擾 註記 `'`\n    * 外部干擾 註記 `-`\n\n---\n\n# References\n","lastmodified":"2023-01-07T06:57:36.690851697Z","tags":null},"/publish/python-asyncio-202301071423":{"title":"python asyncio-202301071423","content":"\n# python asyncio-202301071423\n\n# Summary\n\n在這篇文章你會學到:\n\n- AsyncIO 基本概念\n- Awaitable: Coroutines, Tasks and Future\n- AsyncIO Context Manager \u0026 Iterator\n\n# Notes\n\n## What is AsyncIO ?\n\n看一下官方 Document 的解釋\n\n\u003e [**asyncio is a library to write concurrent code using the async/await syntax.**](https://docs.python.org/3.9/library/asyncio.html)\n\n常見的誤區是許多剛接觸的人沒有辦法分辨出 **multithreading vs mulitprocessing vs asyncio**, 但這篇並不會詳細分析什麼情況要使用那一種 concurrency, 為了方便還是給一下基本原則:\n\n```python\nif io_bound:\n    if io_very_slow:\n        print(\"Use Asyncio\")\n    else:\n       print(\"Use Threads\")\nelse:\n    print(\"Multi Processing\")\n```\n\n那什麼是 AsyncIO ?\n\n當CPU 執行速度比 IO 快, 為了節省 CPU 等待的浪費, 所以在 CPU 等待 IO 的過程中讓 CPU 去執行其它任務\n\n個人最喜歡的比喻是像 [The Queen's Gambit](https://en.wikipedia.org/wiki/The_Queen%27s_Gambit_(miniseries)) 中有一段女主角一個人跟整個西洋棋社下棋的片段\n\n主角就是運作速度極快的 CPU, 其它人則是速度比較慢的 IO. 主角並不會等待 A 下完才換跟 B 下棋. 而是一但有人移動棋子了, 她就會切換過去給出她的下一步\n\n這樣因為 CPU 跟 IO 不等速, 節省時間而切換 CPU 的狀況就是 AsyncIO\n\n先來張基本流程示意圖\n\n```mermaid\ngraph LR\n    style handler fill:#bbf\n    style EventLoop fill:#f9f\n    style IO fill:#abc\n\n    handler --\u003e EventLoop((Event Loop))\n    EventLoop -- trigger callback ---\u003e handler\n    EventLoop -- Register Callback ---\u003e IO((IO))\n    IO -- Operation Complete ---\u003e EventLoop\n```\n\n想要了解 python asyncio, 就需要理解幾個相關詞跟概念\n\n* **Event loop**\n* **Callback**\n* **Coroutines**\n* **Tasks**\n* **Futures**\n\n那我們開始吧!\n\n## Event Loop\n\n\u003e 西洋棋的比喻: 監聽中的對手名單\n\n負責跑 asynchronous tasks \u0026\u0026 callbacks\n\nEvent loop 會跑在 單一 thread (main thread) 中, 就像一個 todo list \n\nmain thread 會監聽這個 TODO List, 等待它們完成後 呼叫 Callback\n\n## Callback\n\n\u003e 西洋棋的比喻: 對手(任務)\n\n\u003e A subroutine function which is passed as an argument to be executed at some point in the future.\n\n關於 callback 其實在 JS 中很常見, python 中的 callback function:\n\n```python\n\ndef func_b():\n    print(\"func_b\")\n\ndef func_a(callback, *args, **kwargs):\n    print(\"func_a\")\n    callback()  # exec callback func\n\nfunc_a(func_b)  # func_b is callback func_b for func_a\n#  func_a\n#  func_b\n```\n\n在 asyncio 中, callback 是透過 event loop schedule function 被註冊到 EventLoop\n\nEventLoop 的 schedule functions\n\n* [Scheduling callbacks](https://docs.python.org/3/library/asyncio-eventloop.html#scheduling-callbacks)\n* [Scheduling delayed callbacks](https://docs.python.org/3/library/asyncio-eventloop.html#scheduling-delayed-callbacks)\n\n## Awaitables\n\n\u003e Future-like object or a coroutine object\n\nPython 有三個主要的 awaitable objects.\n\n* **Coroutines**\n* **Tasks**\n* **Futures** .\n\n### [Coroutines](https://docs.python.org/3.9/library/asyncio-task.html#coroutines)\n\nCoroutine function: 可以中途 enter/exit/resumed 的 function\n\n感覺跟 callback 很像對吧?\n\n因為 callback 是 low-level API 中的概念(在 EventLoop 中實做). 而 Coroutines 是 high-level API. 透過 `asyncio.run` 執行\n\n```python\nimport asyncio\n\n# nested 是一個 Coroutine\nasync def nested():\n    return 42\n\nasync def main():\n    nested()  # 因為沒有 await, 所以 nested 並不會執行\n\n    print(await nested())  # 這邊會印出 42\n\nasyncio.run(main())\n```\n\nPython Coroutine 在 3.4 asyncio 出現之後從原本的 **Generator-based coroutines**,\n多加了 **Native coroutines**\n\n而其實 Coroutine 這個詞彙在 python 可以同時表示:\n\n* A coroutine function： `async def` function;\n* A coroutine object: an object returned by calling a coroutine function.\n\n所以當有人說 coroutine, 在 python 內可能是\n\n* **Native coroutines** / **Generator-based coroutines**\n* **Coroutine function** / **Coroutine object**\n\n**怎麼區分 Native coroutines \u0026\u0026 Generator-based coroutines 呢?**\n\n1. Native coroutine 沒有 `__iter__` and `__next__` methods.\n    - 不能 iterated over \n    - 不能傳給 `iter()`, `list()`, `tuple()` ...等等內建語法\n    - 不支援原本的 `for ... in loop` 語法\n\n2. Generators-based coroutines 可不可以使用 `yield from` ?\n    - 不能對 Native Coroutine 使用 `yield from` -\u003e `TypeError`\n    - 透過 [@asyncio.coroutine](https://docs.python.org/3/library/asyncio-task.html#asyncio.coroutine) decorator 包裝過的 generator 對 Native coroutine 使用 `yield from`\n\n3. inspect\n    - `inspect.isgenerator()` \u0026\u0026 `inspect.isgeneratorfunction()`\n        - Native coroutines return False\n    - 詳細的 inspect 可以看 [doc](https://docs.python.org/3/library/inspect.html)\n\n### Tasks\n\n* Task 設計是為了讓 coroutines 並發執行, 調度使用的\n\n* 一個 Event loop 同時只會跑一個 task\n\n```python\nimport asyncio\n\nasync def say_after(delay, what):\n    await asyncio.sleep(delay)\n    print(what)\n\nasync def main():\n\n    print(\"start\")\n\n    # 將 task1 \u0026\u0026 task2 註冊到 event loop 中\n    task1 = asyncio.create_task(say_after(1, \"hello\"))\n    task1 = asyncio.create_task(say_after(2, \"world\"))\n\n    # 等到 兩個 task 都執行完, 大約需要兩秒(不是三秒)\n    await task1\n    await task2\n\nasync.run(main())\n```\n\n### [Future](https://docs.python.org/3.9/library/asyncio-future.html#asyncio.Future)\n\n\u003e Future objects are used to bridge low-level callback-based code with high-level async\n\n* asynchronous operation 回傳的最終結果\n* Futures 是 low-level 的 awaitable object\n* 通常 application level 不會需要操作到 future\n\n* Task \u0026\u0026 Coroutines 都是 **future-like** object\n    \u003e future-like object\n    \u003e An object with an __await__ method, or a C object with tp_as_async-\u003eam_await function, returning an iterator. Can be consumed by an await expression in a coroutine. A coroutine waiting for a Future-like object is suspended until the Future-like object's __await__ completes, and returns the result. See Await Expression for details.\n\n\n## Context Manager \u0026\u0026 Iterator\n\n### Asynchronous Context Manager\n\n`async with`\n\n基本的 python context manager 需要定義兩個 funcs, `__enter__` \u0026\u0026 `__exit__`.\n\npython asynchronous context manager 則是需要定義兩個 magic method: `__aenter__` \u0026\u0026 `__aexit__`\n\n```python\nclass AsyncContextManager:\n    async def __aenter__(self):\n        await log('entering context')\n    async def __aexit__(self, exc_type, exc, tb):\n        await log('exiting context')\n```\n\n\n### Asynchronous Iterator\n\n`async for`\n\n基本 Iterator 需要定義 `__iter__`, `__next__`\n\nAsync Iterator -\u003e `__aiter__`, `__anext__`\n\n```python\nclass AsyncIterable\n    def __aiter__(self):\n        return self\n    async def __anext__(self):\n        data = await self.fetch_data()\n        if data:\n            return data\n        else:\n            raise StopAsyncIteration\n```\n\n---\n\n# Recap\n\n如果是第一次接觸 python 的 asyncio 的人, 有可能會搞混 Tasks, \nFuture, Coroutines 這些詞彙的意思.\n\n老實說第一次接觸時也是一頭混亂. 寫這篇時也是不斷的翻 PEP 的內容.\n\nAsyncio 的 API 變動其實滿快的. 所以詳細還是要看 doc\n\n一個成熟的工程師除了使用工具解決問題, 其實還要了解使用的時機跟內部的實作去避免踩雷跟解釋出自己是如何解決問題的\n\n想要研究(自虐) 的人還是把 PEP 看完會有更深的了解喔\n\n---\n\n# References\n\n## PEP List\n\n[PEP 479 -- Change StopIteration handling inside generators](https://www.python.org/dev/peps/pep-0479/)\n[PEP 492](https://www.python.org/dev/peps/pep-0492/)\n\n## Source\n- https://www.youtube.com/watch?v=iG6fr81xHKA\u0026ab_channel=PyCon2017\n- https://jimmy-huang.medium.com/python-asyncio-%E5%8D%94%E7%A8%8B-%E4%BA%8C-e717018bb984\n- https://blog.taiker.space/python-async-io-in-python-a-complete-walkthrough/\n- http://masnun.rocks/2016/10/06/async-python-the-different-forms-of-concurrency/\n","lastmodified":"2023-01-07T06:57:36.690851697Z","tags":null},"/publish/why-mypy-202301071445":{"title":"why mypy-202301071445","content":"\n# why mypy-202301071445\n\n# Summary\n\n- What is mypy\n- Python Annotations\n- Annotation PEPs\n\n# Notes\n\n## What is Mypy?\n\n[Mypy](https://github.com/python/mypy) 是一個 static type checker for Python3 \u0026 Python2.7.\n\n嗯, static type checker. 一定會有一些朋友問說為什麼 python 需要 type checker. python 不是 dynamic-typed language 嘛? 要檢查 type 就不要寫 python 了阿\n\n沒關係我們慢慢解釋\n\n## [PEP -- 483 The Theory of Type Hints](https://www.python.org/dev/peps/pep-0483/) \u0026\u0026 [PEP 484 -- Type Hints](https://www.python.org/dev/peps/pep-0484/)\n\nPEP483, PEP484 是由 Guido van Rossum, Jukka Lehtosalo, Lukasz Langa 在 2014年提出的.\n最後實現在了 python 3.5 上\n\n```python\n# 就像這樣可以指定回傳的 type -\u003e str\ndef func_a(a: str, b: str) -\u003e str:\n    return a + b\n```\n\n值得注意的一個特性是: __python 的 type hints 是 Function Annotations, function annotations 是沒有強制力的__. 如同字面上的意義它就是 function 的註解.\n\n```python\ndef foo(a: str) -\u003e str:\n    \"\"\"Foo.\"\"\"\n        return 'hello' + a\n\n# {function}.__annotations__ 可以呼叫出 Function Annotations\nprint(foo.__annotations__)\n\n# {'a': \u003cclass 'str'\u003e, 'return': \u003cclass 'str'\u003e}\n# 可以看到 `return` 內註明了我們回傳的屬性是 `str`\n```\n\n透過 Function Annotation, python 解放了一些可能性: 第三方套件可以拿到 function return type.\n\n當然在 PEP484 中也有提到 \n\n\u003e It should also be emphasized that Python will remain a dynamically typed language, and the authors have no desire to ever make type hints mandatory, even by convention.\n\n對這樣很好, 創造了很多的可能性, 但我們希望保持簡單.\n\n對這樣很好, python 永遠都是 dynamic-typed language\n\n## 更多 PEP\n\n\n### [PEP 526 -- Syntax for Variable Annotations](https://www.python.org/dev/peps/pep-0526/) \n\nPython Variable Annotations\n\n```python\ninit_var: int\n\nmy_var: int = 5\n\nother_var: int\nother_var = 5\n\nprint(__annotations__)\n\n# {'init_var': \u003cclass 'int'\u003e, 'my_var': \u003cclass 'int'\u003e, 'other_var': \u003cclass 'int'\u003e}\n```\n\n### [PEP 544 -- Protocols: Structural subtyping (static duck typing)](https://www.python.org/dev/peps/pep-0544/)\n\nPython Structural subtyping\n\n簡單理解的話, 就是 golang 的 interface.\n\n```python\nfrom typing import Iterator, Iterable\n\nclass Bucket:\n    ...\n    def __len__(self) -\u003e int: ...\n    def __iter__(self) -\u003e Iterator[int]: ...\n\ndef collect(items: Iterable[int]) -\u003e int: ...\nresult: int = collect(Bucket())  # Passes type check\n\n# Bucker 因為實作了 Iterator 的 __len__ \u0026 __iter__ . 就可以當 Iterator 使用\n```\n\n### [PEP 586 -- Literal Types](https://www.python.org/dev/peps/pep-0586/)\n\n\n在 python3.8 新增的特性: `Literal`\n\n```python\nfrom typing import Literal\n\ndef accepts_only_four(x: Literal[4]) -\u003e None:\n    pass\n\naccepts_only_four(4)   # OK\naccepts_only_four(19)  # Rejected\n```\n\n### [PEP 589 -- TypedDict: Type Hints for Dictionaries with a Fixed Set of Keys](https://www.python.org/dev/peps/pep-0589/)\n\n新增 `TypedDict`\n\n```python\nfrom typing import TypedDict\n\nclass Movie(TypedDict):\n    name: str\n    year: int\n\nmovie: Movie = {\n    'name': 'Blade Runner',\n    'year': 1982,\n}\n```\n\n### [PEP 591 -- Adding a final qualifier to typing](https://www.python.org/dev/peps/pep-0591/)\n\n新增了 `@final` \u0026\u0026 `Final`\n\n`@final` 是 decorator\n\n`Final` 是 annotation\n\n```python\nfrom typing import final\n\n@final\nclass Base:\n    ...\n\nclass Derived(Base):  # Error: Cannot inherit from final class \"Base\"\n    ...\n```\n\n```python\nfrom typing import final\n\nclass Base:\n    @final\n    def foo(self) -\u003e None:\n        ...\n\nclass Derived(Base):\n    def foo(self) -\u003e None:  # Error: Cannot override final attribute \"foo\"\n                            # (previously declared in base class \"Base\")\n        ...\n```\n\n```python\n# With an explicit type\nID: Final[float] = 1\n\n# With no type annotation.\nID: Final = 1\n```\n\n## 所以為什麼需要 Mypy?\n\n所以一切源於 PEP484, 後續的 PEP 是補充概念以及語法.\n一般來說 Mypy 可以被運用在兩個地方\n\n1. Editor check\n2. Testing\n\n我沒有辦法明確的跟你說 Mypy 是必要的且適合每個人. 比起寫一般的 python 會需要打更多字, 遵守更多規範. 但遵循這樣的規範寫程式會有幾個好處：\n\n* 易讀的程式碼\n* 易於重構的程式碼\n* 提升程式碼質量\n\nPython type hints 是屬於 annotations. 它不是強制性的規範. 但大量使用可以有效提昇程式碼的 **質量**.\n\n在日常開發以及正式的專案導入這樣的工具. 你的同事以及未來的你會更加感謝現在的你的.\n\n---\n# References\n\n[PEP 3107 -- Function Annotations](https://www.python.org/dev/peps/pep-3107/)\n","lastmodified":"2023-01-07T06:57:36.690851697Z","tags":null}}