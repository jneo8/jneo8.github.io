{"/":{"title":"jneo8.com","content":"\n# About\n\nThis a jneo8, a software engineer who focus on cloud native/database/devops/backend topics.\n\n\n# Articles\n\n- [List of articles](/tags/articles)\n","lastmodified":"2023-01-07T06:44:41.154752451Z","tags":null},"/publish/python-asyncio-202301071423":{"title":"python asyncio-202301071423","content":"\n# python asyncio-202301071423\n\n# Summary\n\n在這篇文章你會學到:\n\n- AsyncIO 基本概念\n- Awaitable: Coroutines, Tasks and Future\n- AsyncIO Context Manager \u0026 Iterator\n\n# Notes\n\n## What is AsyncIO ?\n\n看一下官方 Document 的解釋\n\n\u003e [**asyncio is a library to write concurrent code using the async/await syntax.**](https://docs.python.org/3.9/library/asyncio.html)\n\n常見的誤區是許多剛接觸的人沒有辦法分辨出 **multithreading vs mulitprocessing vs asyncio**, 但這篇並不會詳細分析什麼情況要使用那一種 concurrency, 為了方便還是給一下基本原則:\n\n```python\nif io_bound:\n    if io_very_slow:\n        print(\"Use Asyncio\")\n    else:\n       print(\"Use Threads\")\nelse:\n    print(\"Multi Processing\")\n```\n\n那什麼是 AsyncIO ?\n\n當CPU 執行速度比 IO 快, 為了節省 CPU 等待的浪費, 所以在 CPU 等待 IO 的過程中讓 CPU 去執行其它任務\n\n個人最喜歡的比喻是像 [The Queen's Gambit](https://en.wikipedia.org/wiki/The_Queen%27s_Gambit_(miniseries)) 中有一段女主角一個人跟整個西洋棋社下棋的片段\n\n主角就是運作速度極快的 CPU, 其它人則是速度比較慢的 IO. 主角並不會等待 A 下完才換跟 B 下棋. 而是一但有人移動棋子了, 她就會切換過去給出她的下一步\n\n這樣因為 CPU 跟 IO 不等速, 節省時間而切換 CPU 的狀況就是 AsyncIO\n\n先來張基本流程示意圖\n\n```mermaid\ngraph LR\n    style handler fill:#bbf\n    style EventLoop fill:#f9f\n    style IO fill:#abc\n\n    handler --\u003e EventLoop((Event Loop))\n    EventLoop -- trigger callback ---\u003e handler\n    EventLoop -- Register Callback ---\u003e IO((IO))\n    IO -- Operation Complete ---\u003e EventLoop\n```\n\n想要了解 python asyncio, 就需要理解幾個相關詞跟概念\n\n* **Event loop**\n* **Callback**\n* **Coroutines**\n* **Tasks**\n* **Futures**\n\n那我們開始吧!\n\n## Event Loop\n\n\u003e 西洋棋的比喻: 監聽中的對手名單\n\n負責跑 asynchronous tasks \u0026\u0026 callbacks\n\nEvent loop 會跑在 單一 thread (main thread) 中, 就像一個 todo list \n\nmain thread 會監聽這個 TODO List, 等待它們完成後 呼叫 Callback\n\n## Callback\n\n\u003e 西洋棋的比喻: 對手(任務)\n\n\u003e A subroutine function which is passed as an argument to be executed at some point in the future.\n\n關於 callback 其實在 JS 中很常見, python 中的 callback function:\n\n```python\n\ndef func_b():\n    print(\"func_b\")\n\ndef func_a(callback, *args, **kwargs):\n    print(\"func_a\")\n    callback()  # exec callback func\n\nfunc_a(func_b)  # func_b is callback func_b for func_a\n#  func_a\n#  func_b\n```\n\n在 asyncio 中, callback 是透過 event loop schedule function 被註冊到 EventLoop\n\nEventLoop 的 schedule functions\n\n* [Scheduling callbacks](https://docs.python.org/3/library/asyncio-eventloop.html#scheduling-callbacks)\n* [Scheduling delayed callbacks](https://docs.python.org/3/library/asyncio-eventloop.html#scheduling-delayed-callbacks)\n\n## Awaitables\n\n\u003e Future-like object or a coroutine object\n\nPython 有三個主要的 awaitable objects.\n\n* **Coroutines**\n* **Tasks**\n* **Futures** .\n\n### [Coroutines](https://docs.python.org/3.9/library/asyncio-task.html#coroutines)\n\nCoroutine function: 可以中途 enter/exit/resumed 的 function\n\n感覺跟 callback 很像對吧?\n\n因為 callback 是 low-level API 中的概念(在 EventLoop 中實做). 而 Coroutines 是 high-level API. 透過 `asyncio.run` 執行\n\n```python\nimport asyncio\n\n# nested 是一個 Coroutine\nasync def nested():\n    return 42\n\nasync def main():\n    nested()  # 因為沒有 await, 所以 nested 並不會執行\n\n    print(await nested())  # 這邊會印出 42\n\nasyncio.run(main())\n```\n\nPython Coroutine 在 3.4 asyncio 出現之後從原本的 **Generator-based coroutines**,\n多加了 **Native coroutines**\n\n而其實 Coroutine 這個詞彙在 python 可以同時表示:\n\n* A coroutine function： `async def` function;\n* A coroutine object: an object returned by calling a coroutine function.\n\n所以當有人說 coroutine, 在 python 內可能是\n\n* **Native coroutines** / **Generator-based coroutines**\n* **Coroutine function** / **Coroutine object**\n\n**怎麼區分 Native coroutines \u0026\u0026 Generator-based coroutines 呢?**\n\n1. Native coroutine 沒有 `__iter__` and `__next__` methods.\n    - 不能 iterated over \n    - 不能傳給 `iter()`, `list()`, `tuple()` ...等等內建語法\n    - 不支援原本的 `for ... in loop` 語法\n\n2. Generators-based coroutines 可不可以使用 `yield from` ?\n    - 不能對 Native Coroutine 使用 `yield from` -\u003e `TypeError`\n    - 透過 [@asyncio.coroutine](https://docs.python.org/3/library/asyncio-task.html#asyncio.coroutine) decorator 包裝過的 generator 對 Native coroutine 使用 `yield from`\n\n3. inspect\n    - `inspect.isgenerator()` \u0026\u0026 `inspect.isgeneratorfunction()`\n        - Native coroutines return False\n    - 詳細的 inspect 可以看 [doc](https://docs.python.org/3/library/inspect.html)\n\n### Tasks\n\n* Task 設計是為了讓 coroutines 並發執行, 調度使用的\n\n* 一個 Event loop 同時只會跑一個 task\n\n```python\nimport asyncio\n\nasync def say_after(delay, what):\n    await asyncio.sleep(delay)\n    print(what)\n\nasync def main():\n\n    print(\"start\")\n\n    # 將 task1 \u0026\u0026 task2 註冊到 event loop 中\n    task1 = asyncio.create_task(say_after(1, \"hello\"))\n    task1 = asyncio.create_task(say_after(2, \"world\"))\n\n    # 等到 兩個 task 都執行完, 大約需要兩秒(不是三秒)\n    await task1\n    await task2\n\nasync.run(main())\n```\n\n### [Future](https://docs.python.org/3.9/library/asyncio-future.html#asyncio.Future)\n\n\u003e Future objects are used to bridge low-level callback-based code with high-level async\n\n* asynchronous operation 回傳的最終結果\n* Futures 是 low-level 的 awaitable object\n* 通常 application level 不會需要操作到 future\n\n* Task \u0026\u0026 Coroutines 都是 **future-like** object\n    \u003e future-like object\n    \u003e An object with an __await__ method, or a C object with tp_as_async-\u003eam_await function, returning an iterator. Can be consumed by an await expression in a coroutine. A coroutine waiting for a Future-like object is suspended until the Future-like object's __await__ completes, and returns the result. See Await Expression for details.\n\n\n## Context Manager \u0026\u0026 Iterator\n\n### Asynchronous Context Manager\n\n`async with`\n\n基本的 python context manager 需要定義兩個 funcs, `__enter__` \u0026\u0026 `__exit__`.\n\npython asynchronous context manager 則是需要定義兩個 magic method: `__aenter__` \u0026\u0026 `__aexit__`\n\n```python\nclass AsyncContextManager:\n    async def __aenter__(self):\n        await log('entering context')\n    async def __aexit__(self, exc_type, exc, tb):\n        await log('exiting context')\n```\n\n\n### Asynchronous Iterator\n\n`async for`\n\n基本 Iterator 需要定義 `__iter__`, `__next__`\n\nAsync Iterator -\u003e `__aiter__`, `__anext__`\n\n```python\nclass AsyncIterable\n    def __aiter__(self):\n        return self\n    async def __anext__(self):\n        data = await self.fetch_data()\n        if data:\n            return data\n        else:\n            raise StopAsyncIteration\n```\n\n---\n\n# Recap\n\n如果是第一次接觸 python 的 asyncio 的人, 有可能會搞混 Tasks, \nFuture, Coroutines 這些詞彙的意思.\n\n老實說第一次接觸時也是一頭混亂. 寫這篇時也是不斷的翻 PEP 的內容.\n\nAsyncio 的 API 變動其實滿快的. 所以詳細還是要看 doc\n\n一個成熟的工程師除了使用工具解決問題, 其實還要了解使用的時機跟內部的實作去避免踩雷跟解釋出自己是如何解決問題的\n\n想要研究(自虐) 的人還是把 PEP 看完會有更深的了解喔\n\n---\n\n# References\n\n## PEP List\n\n[PEP 479 -- Change StopIteration handling inside generators](https://www.python.org/dev/peps/pep-0479/)\n[PEP 492](https://www.python.org/dev/peps/pep-0492/)\n\n## Source\n- https://www.youtube.com/watch?v=iG6fr81xHKA\u0026ab_channel=PyCon2017\n- https://jimmy-huang.medium.com/python-asyncio-%E5%8D%94%E7%A8%8B-%E4%BA%8C-e717018bb984\n- https://blog.taiker.space/python-async-io-in-python-a-complete-walkthrough/\n- http://masnun.rocks/2016/10/06/async-python-the-different-forms-of-concurrency/\n","lastmodified":"2023-01-07T06:44:41.154752451Z","tags":null}}